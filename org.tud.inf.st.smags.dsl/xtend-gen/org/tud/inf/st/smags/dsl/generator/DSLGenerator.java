/**
 * generated by Xtext 2.10.0
 */
package org.tud.inf.st.smags.dsl.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.tud.inf.st.smags.model.smags.ActivateRoleModelOperator;
import org.tud.inf.st.smags.model.smags.Architecture;
import org.tud.inf.st.smags.model.smags.ArchitectureElement;
import org.tud.inf.st.smags.model.smags.BindOperator;
import org.tud.inf.st.smags.model.smags.Component;
import org.tud.inf.st.smags.model.smags.ComponentInstance;
import org.tud.inf.st.smags.model.smags.ComponentType;
import org.tud.inf.st.smags.model.smags.CompositionOperator;
import org.tud.inf.st.smags.model.smags.CreateInstanceOperator;
import org.tud.inf.st.smags.model.smags.Deployment;
import org.tud.inf.st.smags.model.smags.DeploymentOperator;
import org.tud.inf.st.smags.model.smags.GenericUse;
import org.tud.inf.st.smags.model.smags.MetaArchitecture;
import org.tud.inf.st.smags.model.smags.MetaArchitectureElement;
import org.tud.inf.st.smags.model.smags.Method;
import org.tud.inf.st.smags.model.smags.Port;
import org.tud.inf.st.smags.model.smags.PortType;
import org.tud.inf.st.smags.model.smags.PortTypeElement;
import org.tud.inf.st.smags.model.smags.PrimitiveUse;
import org.tud.inf.st.smags.model.smags.RoleModel;
import org.tud.inf.st.smags.model.smags.RoleModelSlot;
import org.tud.inf.st.smags.model.smags.SmagsElement;
import org.tud.inf.st.smags.model.smags.SmagsModel;
import org.tud.inf.st.smags.model.smags.Type;
import org.tud.inf.st.smags.model.smags.TypeBinding;
import org.tud.inf.st.smags.model.smags.TypeUse;
import org.tud.inf.st.smags.model.smags.Variable;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class DSLGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EList<EObject> _contents = resource.getContents();
    Iterable<SmagsModel> _filter = Iterables.<SmagsModel>filter(_contents, SmagsModel.class);
    for (final SmagsModel m : _filter) {
      {
        EList<SmagsElement> _elements = m.getElements();
        Iterable<MetaArchitecture> _filter_1 = Iterables.<MetaArchitecture>filter(_elements, MetaArchitecture.class);
        for (final MetaArchitecture a : _filter_1) {
          {
            final String package_ = this.pkg(a);
            String _name = a.getName();
            String _firstUpper = StringExtensions.toFirstUpper(_name);
            final String portTypeMarkerName = (_firstUpper + "PortType");
            String _replaceAll = package_.replaceAll("\\.", "/");
            String _plus = (_replaceAll + "/");
            String _name_1 = a.getName();
            String _firstUpper_1 = StringExtensions.toFirstUpper(_name_1);
            String _plus_1 = (_plus + _firstUpper_1);
            String _plus_2 = (_plus_1 + "MetaArchitecture.java");
            CharSequence _compile = this.compile(package_, a);
            fsa.generateFile(_plus_2, _compile);
            String _replaceAll_1 = package_.replaceAll("\\.", "/");
            String _plus_3 = (_replaceAll_1 + "/");
            String _plus_4 = (_plus_3 + portTypeMarkerName);
            String _plus_5 = (_plus_4 + ".java");
            CharSequence _marker = this.marker(package_, portTypeMarkerName);
            fsa.generateFile(_plus_5, _marker);
            EList<MetaArchitectureElement> _elements_1 = a.getElements();
            Iterable<ComponentType> _filter_2 = Iterables.<ComponentType>filter(_elements_1, ComponentType.class);
            for (final ComponentType c : _filter_2) {
              String _replaceAll_2 = package_.replaceAll("\\.", "/");
              String _plus_6 = (_replaceAll_2 + "/");
              String _name_2 = c.getName();
              String _firstUpper_2 = StringExtensions.toFirstUpper(_name_2);
              String _plus_7 = (_plus_6 + _firstUpper_2);
              String _plus_8 = (_plus_7 + ".java");
              CharSequence _compile_1 = this.compile(package_, c, portTypeMarkerName);
              fsa.generateFile(_plus_8, _compile_1);
            }
            EList<MetaArchitectureElement> _elements_2 = a.getElements();
            Iterable<PortType> _filter_3 = Iterables.<PortType>filter(_elements_2, PortType.class);
            for (final PortType p : _filter_3) {
              String _replaceAll_3 = package_.replaceAll("\\.", "/");
              String _plus_9 = (_replaceAll_3 + "/");
              String _name_3 = p.getName();
              String _firstUpper_3 = StringExtensions.toFirstUpper(_name_3);
              String _plus_10 = (_plus_9 + _firstUpper_3);
              String _plus_11 = (_plus_10 + ".java");
              CharSequence _compile_2 = this.compile(package_, p, portTypeMarkerName);
              fsa.generateFile(_plus_11, _compile_2);
            }
          }
        }
        EList<SmagsElement> _elements_1 = m.getElements();
        Iterable<Architecture> _filter_2 = Iterables.<Architecture>filter(_elements_1, Architecture.class);
        for (final Architecture a_1 : _filter_2) {
          {
            final String package_ = this.pkg(a_1);
            String _replaceAll = package_.replaceAll("\\.", "/");
            String _plus = (_replaceAll + "/");
            String _name = a_1.getName();
            String _firstUpper = StringExtensions.toFirstUpper(_name);
            String _plus_1 = (_plus + _firstUpper);
            String _plus_2 = (_plus_1 + "Architecture.java");
            CharSequence _compile = this.compile(package_, a_1);
            fsa.generateFile(_plus_2, _compile);
            EList<ArchitectureElement> _elements_2 = a_1.getElements();
            Iterable<Component> _filter_3 = Iterables.<Component>filter(_elements_2, Component.class);
            for (final Component c : _filter_3) {
              String _replaceAll_1 = package_.replaceAll("\\.", "/");
              String _plus_3 = (_replaceAll_1 + "/");
              String _name_1 = c.getName();
              String _firstUpper_1 = StringExtensions.toFirstUpper(_name_1);
              String _plus_4 = (_plus_3 + _firstUpper_1);
              String _plus_5 = (_plus_4 + ".java");
              CharSequence _compile_1 = this.compile(package_, c);
              fsa.generateFile(_plus_5, _compile_1);
            }
            EList<ArchitectureElement> _elements_3 = a_1.getElements();
            Iterable<Port> _filter_4 = Iterables.<Port>filter(_elements_3, Port.class);
            for (final Port p : _filter_4) {
              String _replaceAll_2 = package_.replaceAll("\\.", "/");
              String _plus_6 = (_replaceAll_2 + "/");
              String _name_2 = p.getName();
              String _firstUpper_2 = StringExtensions.toFirstUpper(_name_2);
              String _plus_7 = (_plus_6 + _firstUpper_2);
              String _plus_8 = (_plus_7 + ".java");
              CharSequence _compile_2 = this.compile(package_, p);
              fsa.generateFile(_plus_8, _compile_2);
            }
            EList<ArchitectureElement> _elements_4 = a_1.getElements();
            Iterable<Deployment> _filter_5 = Iterables.<Deployment>filter(_elements_4, Deployment.class);
            for (final Deployment d : _filter_5) {
              String _replaceAll_3 = package_.replaceAll("\\.", "/");
              String _plus_9 = (_replaceAll_3 + "/");
              String _name_3 = d.getName();
              String _firstUpper_3 = StringExtensions.toFirstUpper(_name_3);
              String _plus_10 = (_plus_9 + _firstUpper_3);
              String _plus_11 = (_plus_10 + ".java");
              CharSequence _compile_3 = this.compile(package_, d);
              fsa.generateFile(_plus_11, _compile_3);
            }
          }
        }
      }
    }
  }
  
  public String pkg(final MetaArchitecture a) {
    String _namespace = a.getNamespace();
    boolean _equals = Objects.equal(_namespace, null);
    if (_equals) {
      String _name = a.getName();
      return _name.toLowerCase();
    } else {
      return a.getNamespace();
    }
  }
  
  public String pkg(final Architecture a) {
    String _namespace = a.getNamespace();
    boolean _equals = Objects.equal(_namespace, null);
    if (_equals) {
      String _name = a.getName();
      return _name.toLowerCase();
    } else {
      return a.getNamespace();
    }
  }
  
  public String commaList(final Iterable<String> list) {
    final StringBuffer out = new StringBuffer();
    final Iterator<String> i = list.iterator();
    while (i.hasNext()) {
      {
        String _next = i.next();
        out.append(_next);
        boolean _hasNext = i.hasNext();
        if (_hasNext) {
          out.append(", ");
        }
      }
    }
    return out.toString();
  }
  
  public Set<Type> usedTypes(final PortType p) {
    final HashSet<Type> used = new HashSet<Type>();
    EList<PortTypeElement> _elements = p.getElements();
    Iterable<Variable> _filter = Iterables.<Variable>filter(_elements, Variable.class);
    final Function1<Variable, Boolean> _function = (Variable v) -> {
      TypeUse _type = v.getType();
      return Boolean.valueOf((_type instanceof GenericUse));
    };
    Iterable<Variable> _filter_1 = IterableExtensions.<Variable>filter(_filter, _function);
    final Consumer<Variable> _function_1 = (Variable v) -> {
      Type _type = ((GenericUse) v).getType();
      used.add(_type);
    };
    _filter_1.forEach(_function_1);
    EList<PortTypeElement> _elements_1 = p.getElements();
    Iterable<Method> _filter_2 = Iterables.<Method>filter(_elements_1, Method.class);
    final Consumer<Method> _function_2 = (Method m) -> {
      Set<Type> _usedTypes = this.usedTypes(m);
      used.addAll(_usedTypes);
    };
    _filter_2.forEach(_function_2);
    return used;
  }
  
  public Set<Type> usedTypes(final Method m) {
    final HashSet<Type> used = new HashSet<Type>();
    TypeUse _returnType = m.getReturnType();
    if ((_returnType instanceof GenericUse)) {
      TypeUse _returnType_1 = m.getReturnType();
      Type _type = ((GenericUse) _returnType_1).getType();
      used.add(_type);
    }
    EList<Variable> _args = m.getArgs();
    final Function1<Variable, Boolean> _function = (Variable v) -> {
      TypeUse _type_1 = v.getType();
      return Boolean.valueOf((_type_1 instanceof GenericUse));
    };
    Iterable<Variable> _filter = IterableExtensions.<Variable>filter(_args, _function);
    final Consumer<Variable> _function_1 = (Variable v) -> {
      TypeUse _type_1 = v.getType();
      Type _type_2 = ((GenericUse) _type_1).getType();
      used.add(_type_2);
    };
    _filter.forEach(_function_1);
    return used;
  }
  
  public String binding(final Type t, final Architecture a) {
    EList<TypeBinding> _typeBindings = a.getTypeBindings();
    final Function1<TypeBinding, Boolean> _function = (TypeBinding b) -> {
      Type _type = b.getType();
      return Boolean.valueOf(Objects.equal(_type, t));
    };
    TypeBinding _findFirst = IterableExtensions.<TypeBinding>findFirst(_typeBindings, _function);
    return _findFirst.getImplementation();
  }
  
  public String binding(final TypeUse t, final Architecture a) {
    if ((t instanceof GenericUse)) {
      Type _type = ((GenericUse) t).getType();
      return this.binding(_type, a);
    } else {
      return ((PrimitiveUse) t).getType();
    }
  }
  
  public CharSequence marker(final String pkg, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(pkg, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public interface ");
    _builder.append(name, "");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final TypeUse t) {
    CharSequence _xifexpression = null;
    if ((t instanceof GenericUse)) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("T");
      Type _type = ((GenericUse) t).getType();
      String _name = _type.getName();
      String _firstUpper = StringExtensions.toFirstUpper(_name);
      _builder.append(_firstUpper, "");
      _xifexpression = _builder;
    } else {
      _xifexpression = ((PrimitiveUse) t).getType();
    }
    return _xifexpression;
  }
  
  public CharSequence compile(final Variable v) {
    StringConcatenation _builder = new StringConcatenation();
    TypeUse _type = v.getType();
    CharSequence _compile = this.compile(_type);
    _builder.append(_compile, "");
    _builder.append(" ");
    String _name = v.getName();
    _builder.append(_name, "");
    return _builder;
  }
  
  public CharSequence compileInterface(final Method m) {
    StringConcatenation _builder = new StringConcatenation();
    TypeUse _returnType = m.getReturnType();
    CharSequence _compile = this.compile(_returnType);
    _builder.append(_compile, "");
    _builder.append(" ");
    String _name = m.getName();
    _builder.append(_name, "");
    _builder.append("(");
    EList<Variable> _args = m.getArgs();
    final Function1<Variable, String> _function = (Variable a) -> {
      CharSequence _compile_1 = this.compile(a);
      return _compile_1.toString();
    };
    List<String> _map = ListExtensions.<Variable, String>map(_args, _function);
    String _commaList = this.commaList(_map);
    _builder.append(_commaList, "");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compileImpl(final Method m, final Architecture a) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("@Override");
    _builder.newLine();
    _builder.append("public ");
    TypeUse _returnType = m.getReturnType();
    String _binding = this.binding(_returnType, a);
    _builder.append(_binding, "");
    _builder.append(" ");
    String _name = m.getName();
    _builder.append(_name, "");
    _builder.append("(");
    EList<Variable> _args = m.getArgs();
    final Function1<Variable, String> _function = (Variable e) -> {
      TypeUse _type = e.getType();
      String _binding_1 = this.binding(_type, a);
      String _plus = (_binding_1 + " ");
      String _name_1 = e.getName();
      return (_plus + _name_1);
    };
    List<String> _map = ListExtensions.<Variable, String>map(_args, _function);
    String _commaList = this.commaList(_map);
    _builder.append(_commaList, "");
    _builder.append("){");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("//TODO implement");
    _builder.newLine();
    _builder.append("\t");
    {
      TypeUse _returnType_1 = m.getReturnType();
      String _binding_1 = this.binding(_returnType_1, a);
      boolean _equals = _binding_1.equals("void");
      boolean _not = (!_equals);
      if (_not) {
        _builder.append("return null;");
      }
    }
    _builder.append("\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compileDelegate(final Method m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public ");
    TypeUse _returnType = m.getReturnType();
    CharSequence _compile = this.compile(_returnType);
    _builder.append(_compile, "");
    _builder.append(" ");
    String _name = m.getName();
    _builder.append(_name, "");
    _builder.append("(");
    EList<Variable> _args = m.getArgs();
    final Function1<Variable, String> _function = (Variable a) -> {
      CharSequence _compile_1 = this.compile(a);
      return _compile_1.toString();
    };
    List<String> _map = ListExtensions.<Variable, String>map(_args, _function);
    String _commaList = this.commaList(_map);
    _builder.append(_commaList, "");
    _builder.append("){");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("Method m = Arrays.stream(");
    EObject _eContainer = m.eContainer();
    String _name_1 = ((PortType) _eContainer).getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name_1);
    _builder.append(_firstUpper, "\t");
    _builder.append(".class.getMethods()).filter(e -> e.getName().equals(\"");
    String _name_2 = m.getName();
    _builder.append(_name_2, "\t");
    _builder.append("\")).findFirst().get();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("return (");
    TypeUse _returnType_1 = m.getReturnType();
    CharSequence _compile_1 = this.compile(_returnType_1);
    _builder.append(_compile_1, "\t");
    _builder.append(")delegate(m");
    {
      EList<Variable> _args_1 = m.getArgs();
      int _size = _args_1.size();
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        _builder.append(",");
        EList<Variable> _args_2 = m.getArgs();
        final Function1<Variable, String> _function_1 = (Variable a) -> {
          return a.getName();
        };
        List<String> _map_1 = ListExtensions.<Variable, String>map(_args_2, _function_1);
        String _commaList_1 = this.commaList(_map_1);
        _builder.append(_commaList_1, "\t");
      }
    }
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence genericName(final MetaArchitecture a) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = a.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    _builder.append("MetaArchitecture");
    {
      EList<MetaArchitectureElement> _elements = a.getElements();
      Iterable<PortType> _filter = Iterables.<PortType>filter(_elements, PortType.class);
      final Function1<PortType, Boolean> _function = (PortType pt) -> {
        Set<Type> _usedTypes = this.usedTypes(pt);
        int _size = _usedTypes.size();
        return Boolean.valueOf((_size > 0));
      };
      boolean _exists = IterableExtensions.<PortType>exists(_filter, _function);
      if (_exists) {
        _builder.append("<");
        EList<MetaArchitectureElement> _elements_1 = a.getElements();
        Iterable<PortType> _filter_1 = Iterables.<PortType>filter(_elements_1, PortType.class);
        final Function1<PortType, Set<Type>> _function_1 = (PortType pt) -> {
          return this.usedTypes(pt);
        };
        Iterable<Set<Type>> _map = IterableExtensions.<PortType, Set<Type>>map(_filter_1, _function_1);
        Iterable<Type> _flatten = Iterables.<Type>concat(_map);
        final Function1<Type, String> _function_2 = (Type t) -> {
          String _name_1 = t.getName();
          return ("T" + _name_1);
        };
        Iterable<String> _map_1 = IterableExtensions.<Type, String>map(_flatten, _function_2);
        Set<String> _set = IterableExtensions.<String>toSet(_map_1);
        String _commaList = this.commaList(_set);
        _builder.append(_commaList, "");
        _builder.append(">");
      }
    }
    return _builder;
  }
  
  public CharSequence genericName(final ComponentType c) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = c.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    {
      EList<PortType> _provides = c.getProvides();
      final Function1<PortType, Boolean> _function = (PortType pt) -> {
        Set<Type> _usedTypes = this.usedTypes(pt);
        int _size = _usedTypes.size();
        return Boolean.valueOf((_size > 0));
      };
      boolean _exists = IterableExtensions.<PortType>exists(_provides, _function);
      if (_exists) {
        _builder.append("<");
        EList<PortType> _provides_1 = c.getProvides();
        final Function1<PortType, Set<Type>> _function_1 = (PortType pt) -> {
          return this.usedTypes(pt);
        };
        List<Set<Type>> _map = ListExtensions.<PortType, Set<Type>>map(_provides_1, _function_1);
        Iterable<Type> _flatten = Iterables.<Type>concat(_map);
        final Function1<Type, String> _function_2 = (Type t) -> {
          String _name_1 = t.getName();
          return ("T" + _name_1);
        };
        Iterable<String> _map_1 = IterableExtensions.<Type, String>map(_flatten, _function_2);
        Set<String> _set = IterableExtensions.<String>toSet(_map_1);
        String _commaList = this.commaList(_set);
        _builder.append(_commaList, "");
        _builder.append(">");
      }
    }
    return _builder;
  }
  
  public CharSequence genericName(final PortType p) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = p.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    {
      Set<Type> _usedTypes = this.usedTypes(p);
      boolean _isEmpty = _usedTypes.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("<");
        Set<Type> _usedTypes_1 = this.usedTypes(p);
        final Function1<Type, String> _function = (Type t) -> {
          String _name_1 = t.getName();
          return ("T" + _name_1);
        };
        Iterable<String> _map = IterableExtensions.<Type, String>map(_usedTypes_1, _function);
        Set<String> _set = IterableExtensions.<String>toSet(_map);
        String _commaList = this.commaList(_set);
        _builder.append(_commaList, "");
        _builder.append(">");
      }
    }
    return _builder;
  }
  
  public CharSequence compile(final String pkg, final MetaArchitecture a) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(pkg, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public abstract class ");
    CharSequence _genericName = this.genericName(a);
    _builder.append(_genericName, "");
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    {
      EList<MetaArchitectureElement> _elements = a.getElements();
      Iterable<RoleModel> _filter = Iterables.<RoleModel>filter(_elements, RoleModel.class);
      for(final RoleModel rm : _filter) {
        _builder.append("\t");
        _builder.append("public void activate");
        String _name = rm.getName();
        String _firstUpper = StringExtensions.toFirstUpper(_name);
        _builder.append(_firstUpper, "\t");
        _builder.append("(");
        EList<RoleModelSlot> _slots = rm.getSlots();
        final Function1<RoleModelSlot, String> _function = (RoleModelSlot s) -> {
          ComponentType _type = s.getType();
          CharSequence _genericName_1 = this.genericName(_type);
          String _plus = (_genericName_1 + " ");
          String _name_1 = s.getName();
          return (_plus + _name_1);
        };
        List<String> _map = ListExtensions.<RoleModelSlot, String>map(_slots, _function);
        String _commaList = this.commaList(_map);
        _builder.append(_commaList, "\t");
        _builder.append("){");
        _builder.newLineIfNotEmpty();
        {
          EList<CompositionOperator> _initialization = rm.getInitialization();
          Iterable<BindOperator> _filter_1 = Iterables.<BindOperator>filter(_initialization, BindOperator.class);
          for(final BindOperator op : _filter_1) {
            _builder.append("\t");
            _builder.append("\t");
            RoleModelSlot _slot = op.getSlot();
            String _name_1 = _slot.getName();
            _builder.append(_name_1, "\t\t");
            _builder.append(".playRole(create");
            PortType _to = op.getTo();
            String _name_2 = _to.getName();
            String _firstUpper_1 = StringExtensions.toFirstUpper(_name_2);
            _builder.append(_firstUpper_1, "\t\t");
            _builder.append("(");
            RoleModelSlot _slot_1 = op.getSlot();
            String _name_3 = _slot_1.getName();
            _builder.append(_name_3, "\t\t");
            _builder.append("));");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("\t\t\t\t");
    _builder.newLine();
    {
      EList<MetaArchitectureElement> _elements_1 = a.getElements();
      Iterable<PortType> _filter_2 = Iterables.<PortType>filter(_elements_1, PortType.class);
      for(final PortType pt : _filter_2) {
        _builder.append("\t");
        _builder.append("public abstract ");
        CharSequence _genericName_1 = this.genericName(pt);
        _builder.append(_genericName_1, "\t");
        _builder.append(" create");
        String _name_4 = pt.getName();
        String _firstUpper_2 = StringExtensions.toFirstUpper(_name_4);
        _builder.append(_firstUpper_2, "\t");
        _builder.append("(");
        CharSequence _genericName_2 = this.genericName(pt);
        _builder.append(_genericName_2, "\t");
        _builder.append(" base);");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final String pkg, final ComponentType c, final String portTypeMarker) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(pkg, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import java.util.Stack;");
    _builder.newLine();
    _builder.append("import java.lang.reflect.Method;");
    _builder.newLine();
    {
      EList<PortType> _provides = c.getProvides();
      int _size = _provides.size();
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        _builder.append("import java.util.Arrays;");
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public abstract class ");
    CharSequence _genericName = this.genericName(c);
    _builder.append(_genericName, "");
    _builder.append(" ");
    {
      EList<PortType> _provides_1 = c.getProvides();
      boolean _isEmpty = _provides_1.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("implements ");
        EList<PortType> _provides_2 = c.getProvides();
        final Function1<PortType, String> _function = (PortType pt) -> {
          CharSequence _genericName_1 = this.genericName(pt);
          return (_genericName_1 + "");
        };
        List<String> _map = ListExtensions.<PortType, String>map(_provides_2, _function);
        String _commaList = this.commaList(_map);
        _builder.append(_commaList, "");
      }
    }
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private Stack<");
    _builder.append(portTypeMarker, "\t");
    _builder.append("> roles = new Stack<");
    _builder.append(portTypeMarker, "\t");
    _builder.append(">();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void playRole(");
    _builder.append(portTypeMarker, "\t");
    _builder.append(" p){");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("roles.push(p);\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void dropRole(Class<");
    _builder.append(portTypeMarker, "\t");
    _builder.append("> c) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("for(int i=0;i<roles.size();i++) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if(c.isAssignableFrom(roles.get(i).getClass())){");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("roles.remove(i);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("break;\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} \t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private Object delegate(Method m, Object... args) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Class<?> c = m.getDeclaringClass();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append(portTypeMarker, "\t\t");
    _builder.append(" o = null; ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("for(int i=0;i<roles.size();i++) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if(c.isAssignableFrom(roles.get(i).getClass())){");
    _builder.newLine();
    _builder.append("\t\t     \t");
    _builder.append("o=roles.get(i);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("break;\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} \t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if(o == null)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw new UnsupportedOperationException(\"role \"+c+\" not bound to \"+this);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("else");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("try{");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return m.invoke(o,args);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} catch(Exception e) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw new RuntimeException(e);\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      EList<PortType> _provides_3 = c.getProvides();
      final Function1<PortType, Iterable<Method>> _function_1 = (PortType pt) -> {
        EList<PortTypeElement> _elements = pt.getElements();
        return Iterables.<Method>filter(_elements, Method.class);
      };
      List<Iterable<Method>> _map_1 = ListExtensions.<PortType, Iterable<Method>>map(_provides_3, _function_1);
      Iterable<Method> _flatten = Iterables.<Method>concat(_map_1);
      for(final Method m : _flatten) {
        _builder.append("\t");
        CharSequence _compileDelegate = this.compileDelegate(m);
        _builder.append(_compileDelegate, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final String pkg, final PortType p, final String portTypeMarker) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(pkg, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public interface ");
    CharSequence _genericName = this.genericName(p);
    _builder.append(_genericName, "");
    _builder.append(" extends ");
    _builder.append(portTypeMarker, "");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    {
      EList<PortTypeElement> _elements = p.getElements();
      Iterable<Method> _filter = Iterables.<Method>filter(_elements, Method.class);
      for(final Method m : _filter) {
        _builder.append("\t");
        CharSequence _compileInterface = this.compileInterface(m);
        _builder.append(_compileInterface, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence boundParentName(final Architecture a) {
    StringConcatenation _builder = new StringConcatenation();
    MetaArchitecture _type = a.getType();
    String _name = _type.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    _builder.append("MetaArchitecture");
    {
      MetaArchitecture _type_1 = a.getType();
      EList<MetaArchitectureElement> _elements = _type_1.getElements();
      Iterable<PortType> _filter = Iterables.<PortType>filter(_elements, PortType.class);
      final Function1<PortType, Boolean> _function = (PortType pt) -> {
        Set<Type> _usedTypes = this.usedTypes(pt);
        int _size = _usedTypes.size();
        return Boolean.valueOf((_size > 0));
      };
      boolean _exists = IterableExtensions.<PortType>exists(_filter, _function);
      if (_exists) {
        _builder.append("<");
        MetaArchitecture _type_2 = a.getType();
        EList<MetaArchitectureElement> _elements_1 = _type_2.getElements();
        Iterable<PortType> _filter_1 = Iterables.<PortType>filter(_elements_1, PortType.class);
        final Function1<PortType, Set<Type>> _function_1 = (PortType pt) -> {
          return this.usedTypes(pt);
        };
        Iterable<Set<Type>> _map = IterableExtensions.<PortType, Set<Type>>map(_filter_1, _function_1);
        Iterable<Type> _flatten = Iterables.<Type>concat(_map);
        final Function1<Type, String> _function_2 = (Type t) -> {
          return this.binding(t, a);
        };
        Iterable<String> _map_1 = IterableExtensions.<Type, String>map(_flatten, _function_2);
        Set<String> _set = IterableExtensions.<String>toSet(_map_1);
        String _commaList = this.commaList(_set);
        _builder.append(_commaList, "");
        _builder.append(">");
      }
    }
    return _builder;
  }
  
  public CharSequence boundParentName(final Component c) {
    StringConcatenation _builder = new StringConcatenation();
    ComponentType _type = c.getType();
    String _name = _type.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    {
      ComponentType _type_1 = c.getType();
      EList<PortType> _provides = _type_1.getProvides();
      final Function1<PortType, Boolean> _function = (PortType pt) -> {
        Set<Type> _usedTypes = this.usedTypes(pt);
        int _size = _usedTypes.size();
        return Boolean.valueOf((_size > 0));
      };
      boolean _exists = IterableExtensions.<PortType>exists(_provides, _function);
      if (_exists) {
        _builder.append("<");
        ComponentType _type_2 = c.getType();
        EList<PortType> _provides_1 = _type_2.getProvides();
        final Function1<PortType, Set<Type>> _function_1 = (PortType pt) -> {
          return this.usedTypes(pt);
        };
        List<Set<Type>> _map = ListExtensions.<PortType, Set<Type>>map(_provides_1, _function_1);
        Iterable<Type> _flatten = Iterables.<Type>concat(_map);
        Set<Type> _set = IterableExtensions.<Type>toSet(_flatten);
        final Function1<Type, String> _function_2 = (Type t) -> {
          EObject _eContainer = c.eContainer();
          return this.binding(t, ((Architecture) _eContainer));
        };
        Iterable<String> _map_1 = IterableExtensions.<Type, String>map(_set, _function_2);
        String _commaList = this.commaList(_map_1);
        _builder.append(_commaList, "");
        _builder.append(">");
      }
    }
    return _builder;
  }
  
  public CharSequence boundParentName(final Port p) {
    StringConcatenation _builder = new StringConcatenation();
    PortType _type = p.getType();
    String _name = _type.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    {
      PortType _type_1 = p.getType();
      Set<Type> _usedTypes = this.usedTypes(_type_1);
      int _size = _usedTypes.size();
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        _builder.append("<");
        PortType _type_2 = p.getType();
        Set<Type> _usedTypes_1 = this.usedTypes(_type_2);
        final Function1<Type, String> _function = (Type t) -> {
          EObject _eContainer = p.eContainer();
          return this.binding(t, ((Architecture) _eContainer));
        };
        Iterable<String> _map = IterableExtensions.<Type, String>map(_usedTypes_1, _function);
        String _commaList = this.commaList(_map);
        _builder.append(_commaList, "");
        _builder.append(">");
      }
    }
    return _builder;
  }
  
  public CharSequence compile(final String pkg, final Architecture a) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(pkg, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import ");
    MetaArchitecture _type = a.getType();
    String _pkg = this.pkg(_type);
    _builder.append(_pkg, "");
    _builder.append(".");
    MetaArchitecture _type_1 = a.getType();
    String _name = _type_1.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    _builder.append("MetaArchitecture;");
    _builder.newLineIfNotEmpty();
    {
      EList<ArchitectureElement> _elements = a.getElements();
      Iterable<Port> _filter = Iterables.<Port>filter(_elements, Port.class);
      for(final Port p : _filter) {
        _builder.append("import ");
        MetaArchitecture _type_2 = a.getType();
        String _pkg_1 = this.pkg(_type_2);
        _builder.append(_pkg_1, "");
        _builder.append(".");
        PortType _type_3 = p.getType();
        String _name_1 = _type_3.getName();
        String _firstUpper_1 = StringExtensions.toFirstUpper(_name_1);
        _builder.append(_firstUpper_1, "");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.Map;");
    _builder.newLine();
    _builder.append("import java.util.HashMap;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public class ");
    String _name_2 = a.getName();
    String _firstUpper_2 = StringExtensions.toFirstUpper(_name_2);
    _builder.append(_firstUpper_2, "");
    _builder.append("Architecture extends ");
    CharSequence _boundParentName = this.boundParentName(a);
    _builder.append(_boundParentName, "");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("private Map<String,Object> instances = new HashMap<String,Object>();");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void registerInstance(String name, Object instance){");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("instances.put(name,instance);\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public Object getInstance(String name){");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return instances.get(name);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      EList<ArchitectureElement> _elements_1 = a.getElements();
      Iterable<Port> _filter_1 = Iterables.<Port>filter(_elements_1, Port.class);
      for(final Port p_1 : _filter_1) {
        _builder.append("\t");
        _builder.append("@Override");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("public ");
        String _name_3 = p_1.getName();
        String _firstUpper_3 = StringExtensions.toFirstUpper(_name_3);
        _builder.append(_firstUpper_3, "\t");
        _builder.append(" create");
        PortType _type_4 = p_1.getType();
        String _name_4 = _type_4.getName();
        String _firstUpper_4 = StringExtensions.toFirstUpper(_name_4);
        _builder.append(_firstUpper_4, "\t");
        _builder.append("(");
        CharSequence _boundParentName_1 = this.boundParentName(p_1);
        _builder.append(_boundParentName_1, "\t");
        _builder.append(" base){");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("return new ");
        String _name_5 = p_1.getName();
        String _firstUpper_5 = StringExtensions.toFirstUpper(_name_5);
        _builder.append(_firstUpper_5, "\t\t");
        _builder.append("(base);");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final String pkg, final Component c) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(pkg, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import ");
    ComponentType _type = c.getType();
    EObject _eContainer = _type.eContainer();
    String _pkg = this.pkg(((MetaArchitecture) _eContainer));
    _builder.append(_pkg, "");
    _builder.append(".");
    ComponentType _type_1 = c.getType();
    String _name = _type_1.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public class ");
    String _name_1 = c.getName();
    String _firstUpper_1 = StringExtensions.toFirstUpper(_name_1);
    _builder.append(_firstUpper_1, "");
    _builder.append(" extends ");
    CharSequence _boundParentName = this.boundParentName(c);
    _builder.append(_boundParentName, "");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final String pkg, final Port p) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(pkg, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import ");
    PortType _type = p.getType();
    EObject _eContainer = _type.eContainer();
    String _pkg = this.pkg(((MetaArchitecture) _eContainer));
    _builder.append(_pkg, "");
    _builder.append(".");
    PortType _type_1 = p.getType();
    String _name = _type_1.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public class ");
    String _name_1 = p.getName();
    String _firstUpper_1 = StringExtensions.toFirstUpper(_name_1);
    _builder.append(_firstUpper_1, "");
    _builder.append(" implements ");
    CharSequence _boundParentName = this.boundParentName(p);
    _builder.append(_boundParentName, "");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("protected ");
    CharSequence _boundParentName_1 = this.boundParentName(p);
    _builder.append(_boundParentName_1, "\t");
    _builder.append(" base;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public  ");
    String _name_2 = p.getName();
    String _firstUpper_2 = StringExtensions.toFirstUpper(_name_2);
    _builder.append(_firstUpper_2, "\t");
    _builder.append("(");
    CharSequence _boundParentName_2 = this.boundParentName(p);
    _builder.append(_boundParentName_2, "\t");
    _builder.append("  base){");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("this.base = base;\t\t\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      PortType _type_2 = p.getType();
      EList<PortTypeElement> _elements = _type_2.getElements();
      Iterable<Method> _filter = Iterables.<Method>filter(_elements, Method.class);
      for(final Method m : _filter) {
        _builder.append("\t");
        EObject _eContainer_1 = p.eContainer();
        CharSequence _compileImpl = this.compileImpl(m, ((Architecture) _eContainer_1));
        _builder.append(_compileImpl, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final String pkg, final Deployment d) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(pkg, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("public class ");
    String _name = d.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void runScript(");
    EObject _eContainer = d.eContainer();
    String _name_1 = ((Architecture) _eContainer).getName();
    String _firstUpper_1 = StringExtensions.toFirstUpper(_name_1);
    _builder.append(_firstUpper_1, "\t");
    _builder.append("Architecture architecture) {");
    _builder.newLineIfNotEmpty();
    {
      EList<DeploymentOperator> _script = d.getScript();
      for(final DeploymentOperator op : _script) {
        _builder.append("\t\t");
        {
          if ((op instanceof CreateInstanceOperator)) {
            CharSequence _compile = this.compile(((CreateInstanceOperator) op));
            _builder.append(_compile, "\t\t");
          }
        }
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        {
          if ((op instanceof ActivateRoleModelOperator)) {
            CharSequence _compile_1 = this.compile(((ActivateRoleModelOperator) op));
            _builder.append(_compile_1, "\t\t");
          }
        }
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public static void main(String[] args) {");
    _builder.newLine();
    _builder.append("\t\t");
    EObject _eContainer_1 = d.eContainer();
    String _name_2 = ((Architecture) _eContainer_1).getName();
    String _firstUpper_2 = StringExtensions.toFirstUpper(_name_2);
    _builder.append(_firstUpper_2, "\t\t");
    _builder.append("Architecture architecture = new ");
    EObject _eContainer_2 = d.eContainer();
    String _name_3 = ((Architecture) _eContainer_2).getName();
    String _firstUpper_3 = StringExtensions.toFirstUpper(_name_3);
    _builder.append(_firstUpper_3, "\t\t");
    _builder.append("Architecture();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("new ");
    String _name_4 = d.getName();
    String _firstUpper_4 = StringExtensions.toFirstUpper(_name_4);
    _builder.append(_firstUpper_4, "\t\t");
    _builder.append("().runScript(architecture);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final CreateInstanceOperator o) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("architecture.registerInstance(\"");
    ComponentInstance _instance = o.getInstance();
    String _name = _instance.getName();
    _builder.append(_name, "");
    _builder.append("\",new ");
    ComponentInstance _instance_1 = o.getInstance();
    Component _type = _instance_1.getType();
    String _name_1 = _type.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name_1);
    _builder.append(_firstUpper, "");
    _builder.append("());");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final ActivateRoleModelOperator o) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("architecture.activate");
    RoleModel _roleModel = o.getRoleModel();
    String _name = _roleModel.getName();
    String _firstUpper = StringExtensions.toFirstUpper(_name);
    _builder.append(_firstUpper, "");
    _builder.append("(");
    EList<ComponentInstance> _args = o.getArgs();
    final Function1<ComponentInstance, String> _function = (ComponentInstance ci) -> {
      Component _type = ci.getType();
      String _name_1 = _type.getName();
      String _firstUpper_1 = StringExtensions.toFirstUpper(_name_1);
      String _plus = ("(" + _firstUpper_1);
      String _plus_1 = (_plus + ")architecture.getInstance(\"");
      String _name_2 = ci.getName();
      String _plus_2 = (_plus_1 + _name_2);
      return (_plus_2 + "\")");
    };
    List<String> _map = ListExtensions.<ComponentInstance, String>map(_args, _function);
    String _commaList = this.commaList(_map);
    _builder.append(_commaList, "");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
}
