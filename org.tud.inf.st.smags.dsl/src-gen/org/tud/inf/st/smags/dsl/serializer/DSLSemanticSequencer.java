/*
 * generated by Xtext 2.10.0
 */
package org.tud.inf.st.smags.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.tud.inf.st.smags.dsl.services.DSLGrammarAccess;
import org.tud.inf.st.smags.model.smags.ActivateRoleModelOperator;
import org.tud.inf.st.smags.model.smags.Architecture;
import org.tud.inf.st.smags.model.smags.BindOperator;
import org.tud.inf.st.smags.model.smags.Component;
import org.tud.inf.st.smags.model.smags.ComponentInstance;
import org.tud.inf.st.smags.model.smags.ComponentType;
import org.tud.inf.st.smags.model.smags.CreateInstanceOperator;
import org.tud.inf.st.smags.model.smags.Deployment;
import org.tud.inf.st.smags.model.smags.GenericUse;
import org.tud.inf.st.smags.model.smags.Import;
import org.tud.inf.st.smags.model.smags.MetaArchitecture;
import org.tud.inf.st.smags.model.smags.Method;
import org.tud.inf.st.smags.model.smags.Port;
import org.tud.inf.st.smags.model.smags.PortType;
import org.tud.inf.st.smags.model.smags.PrimitiveUse;
import org.tud.inf.st.smags.model.smags.RoleModel;
import org.tud.inf.st.smags.model.smags.RoleModelSlot;
import org.tud.inf.st.smags.model.smags.SmagsModel;
import org.tud.inf.st.smags.model.smags.SmagsPackage;
import org.tud.inf.st.smags.model.smags.Type;
import org.tud.inf.st.smags.model.smags.TypeBinding;
import org.tud.inf.st.smags.model.smags.Variable;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SmagsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SmagsPackage.ACTIVATE_ROLE_MODEL_OPERATOR:
				sequence_ActivateRoleModelOperator(context, (ActivateRoleModelOperator) semanticObject); 
				return; 
			case SmagsPackage.ARCHITECTURE:
				sequence_Architecture(context, (Architecture) semanticObject); 
				return; 
			case SmagsPackage.BIND_OPERATOR:
				sequence_BindOperator(context, (BindOperator) semanticObject); 
				return; 
			case SmagsPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case SmagsPackage.COMPONENT_INSTANCE:
				sequence_ComponentInstance(context, (ComponentInstance) semanticObject); 
				return; 
			case SmagsPackage.COMPONENT_TYPE:
				sequence_ComponentType(context, (ComponentType) semanticObject); 
				return; 
			case SmagsPackage.CREATE_INSTANCE_OPERATOR:
				sequence_CreateInstanceOperator(context, (CreateInstanceOperator) semanticObject); 
				return; 
			case SmagsPackage.DEPLOYMENT:
				sequence_Deployment(context, (Deployment) semanticObject); 
				return; 
			case SmagsPackage.GENERIC_USE:
				sequence_GenericUse(context, (GenericUse) semanticObject); 
				return; 
			case SmagsPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SmagsPackage.META_ARCHITECTURE:
				sequence_MetaArchitecture(context, (MetaArchitecture) semanticObject); 
				return; 
			case SmagsPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case SmagsPackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case SmagsPackage.PORT_TYPE:
				sequence_PortType(context, (PortType) semanticObject); 
				return; 
			case SmagsPackage.PRIMITIVE_USE:
				sequence_PrimitiveUse(context, (PrimitiveUse) semanticObject); 
				return; 
			case SmagsPackage.ROLE_MODEL:
				sequence_RoleModel(context, (RoleModel) semanticObject); 
				return; 
			case SmagsPackage.ROLE_MODEL_SLOT:
				sequence_RoleModelSlot(context, (RoleModelSlot) semanticObject); 
				return; 
			case SmagsPackage.SMAGS_MODEL:
				sequence_SmagsModel(context, (SmagsModel) semanticObject); 
				return; 
			case SmagsPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case SmagsPackage.TYPE_BINDING:
				sequence_TypeBinding(context, (TypeBinding) semanticObject); 
				return; 
			case SmagsPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     DeploymentOperator returns ActivateRoleModelOperator
	 *     ActivateRoleModelOperator returns ActivateRoleModelOperator
	 *
	 * Constraint:
	 *     (roleModel=[RoleModel|EString] (args+=[ComponentInstance|EString] args+=[ComponentInstance|EString]*)?)
	 */
	protected void sequence_ActivateRoleModelOperator(ISerializationContext context, ActivateRoleModelOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SmagsElement returns Architecture
	 *     Architecture returns Architecture
	 *
	 * Constraint:
	 *     (name=EString type=[MetaArchitecture|EString] namespace=EString? typeBindings+=TypeBinding* elements+=ArchitectureElement*)
	 */
	protected void sequence_Architecture(ISerializationContext context, Architecture semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositionOperator returns BindOperator
	 *     BindOperator returns BindOperator
	 *
	 * Constraint:
	 *     (to=[PortType|EString] slot=[RoleModelSlot|EString])
	 */
	protected void sequence_BindOperator(ISerializationContext context, BindOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.BIND_OPERATOR__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.BIND_OPERATOR__TO));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.BIND_OPERATOR__SLOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.BIND_OPERATOR__SLOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindOperatorAccess().getToPortTypeEStringParserRuleCall_3_0_1(), semanticObject.getTo());
		feeder.accept(grammarAccess.getBindOperatorAccess().getSlotRoleModelSlotEStringParserRuleCall_5_0_1(), semanticObject.getSlot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComponentInstance returns ComponentInstance
	 *
	 * Constraint:
	 *     (name=EString type=[Component|EString])
	 */
	protected void sequence_ComponentInstance(ISerializationContext context, ComponentInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.COMPONENT_INSTANCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.COMPONENT_INSTANCE__NAME));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.COMPONENT_INSTANCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.COMPONENT_INSTANCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentInstanceAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getComponentInstanceAccess().getTypeComponentEStringParserRuleCall_4_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaArchitectureElement returns ComponentType
	 *     ComponentType returns ComponentType
	 *
	 * Constraint:
	 *     (name=EString (provides+=[PortType|EString] provides+=[PortType|EString]*)?)
	 */
	protected void sequence_ComponentType(ISerializationContext context, ComponentType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArchitectureElement returns Component
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (name=EString type=[ComponentType|EString])
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.ARCHITECTURE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.ARCHITECTURE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.COMPONENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.COMPONENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getComponentAccess().getTypeComponentTypeEStringParserRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeploymentOperator returns CreateInstanceOperator
	 *     CreateInstanceOperator returns CreateInstanceOperator
	 *
	 * Constraint:
	 *     instance=ComponentInstance
	 */
	protected void sequence_CreateInstanceOperator(ISerializationContext context, CreateInstanceOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.CREATE_INSTANCE_OPERATOR__INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.CREATE_INSTANCE_OPERATOR__INSTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateInstanceOperatorAccess().getInstanceComponentInstanceParserRuleCall_0(), semanticObject.getInstance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArchitectureElement returns Deployment
	 *     Deployment returns Deployment
	 *
	 * Constraint:
	 *     (name=EString script+=DeploymentOperator*)
	 */
	protected void sequence_Deployment(ISerializationContext context, Deployment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeUse returns GenericUse
	 *     GenericUse returns GenericUse
	 *
	 * Constraint:
	 *     type=[Type|EString]
	 */
	protected void sequence_GenericUse(ISerializationContext context, GenericUse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.GENERIC_USE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.GENERIC_USE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGenericUseAccess().getTypeTypeEStringParserRuleCall_1_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_0_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SmagsElement returns MetaArchitecture
	 *     MetaArchitecture returns MetaArchitecture
	 *
	 * Constraint:
	 *     (name=EString namespace=EString? types+=Type* elements+=MetaArchitectureElement*)
	 */
	protected void sequence_MetaArchitecture(ISerializationContext context, MetaArchitecture semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *     PortTypeElement returns Method
	 *
	 * Constraint:
	 *     (returnType=TypeUse name=EString (args+=Variable args+=Variable*)?)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaArchitectureElement returns PortType
	 *     PortType returns PortType
	 *
	 * Constraint:
	 *     (name=EString elements+=PortTypeElement*)
	 */
	protected void sequence_PortType(ISerializationContext context, PortType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArchitectureElement returns Port
	 *     Port returns Port
	 *
	 * Constraint:
	 *     (name=EString type=[PortType|EString])
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.ARCHITECTURE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.ARCHITECTURE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.PORT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.PORT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPortAccess().getTypePortTypeEStringParserRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeUse returns PrimitiveUse
	 *     PrimitiveUse returns PrimitiveUse
	 *
	 * Constraint:
	 *     type=EString
	 */
	protected void sequence_PrimitiveUse(ISerializationContext context, PrimitiveUse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.PRIMITIVE_USE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.PRIMITIVE_USE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveUseAccess().getTypeEStringParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RoleModelSlot returns RoleModelSlot
	 *
	 * Constraint:
	 *     (type=[ComponentType|EString] name=EString)
	 */
	protected void sequence_RoleModelSlot(ISerializationContext context, RoleModelSlot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.ROLE_MODEL_SLOT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.ROLE_MODEL_SLOT__TYPE));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.ROLE_MODEL_SLOT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.ROLE_MODEL_SLOT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRoleModelSlotAccess().getTypeComponentTypeEStringParserRuleCall_1_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getRoleModelSlotAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaArchitectureElement returns RoleModel
	 *     RoleModel returns RoleModel
	 *
	 * Constraint:
	 *     (name=EString (slots+=RoleModelSlot slots+=RoleModelSlot*)? initialization+=CompositionOperator*)
	 */
	protected void sequence_RoleModel(ISerializationContext context, RoleModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SmagsModel returns SmagsModel
	 *
	 * Constraint:
	 *     (imports+=Import* elements+=SmagsElement*)
	 */
	protected void sequence_SmagsModel(ISerializationContext context, SmagsModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeBinding returns TypeBinding
	 *
	 * Constraint:
	 *     (type=[Type|ID] implementation=EString)
	 */
	protected void sequence_TypeBinding(ISerializationContext context, TypeBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.TYPE_BINDING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.TYPE_BINDING__TYPE));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.TYPE_BINDING__IMPLEMENTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.TYPE_BINDING__IMPLEMENTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeBindingAccess().getTypeTypeIDTerminalRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getTypeBindingAccess().getImplementationEStringParserRuleCall_2_0(), semanticObject.getImplementation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *     PortTypeElement returns Variable
	 *
	 * Constraint:
	 *     (type=TypeUse name=ID)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.PORT_TYPE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.PORT_TYPE_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getTypeTypeUseParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
