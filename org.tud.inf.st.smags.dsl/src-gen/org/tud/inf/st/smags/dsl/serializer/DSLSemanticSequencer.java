/*
 * generated by Xtext 2.10.0
 */
package org.tud.inf.st.smags.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.tud.inf.st.smags.dsl.services.DSLGrammarAccess;
import org.tud.inf.st.smags.model.smags.Architecture;
import org.tud.inf.st.smags.model.smags.BindOperator;
import org.tud.inf.st.smags.model.smags.Component;
import org.tud.inf.st.smags.model.smags.ComponentType;
import org.tud.inf.st.smags.model.smags.ExternalType;
import org.tud.inf.st.smags.model.smags.Import;
import org.tud.inf.st.smags.model.smags.MetaArchitecture;
import org.tud.inf.st.smags.model.smags.Method;
import org.tud.inf.st.smags.model.smags.Port;
import org.tud.inf.st.smags.model.smags.PortType;
import org.tud.inf.st.smags.model.smags.PrimitiveType;
import org.tud.inf.st.smags.model.smags.RoleModel;
import org.tud.inf.st.smags.model.smags.RoleModelSlot;
import org.tud.inf.st.smags.model.smags.SmagsModel;
import org.tud.inf.st.smags.model.smags.SmagsPackage;
import org.tud.inf.st.smags.model.smags.TypeBinding;
import org.tud.inf.st.smags.model.smags.Variable;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SmagsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SmagsPackage.ARCHITECTURE:
				sequence_Architecture(context, (Architecture) semanticObject); 
				return; 
			case SmagsPackage.BIND_OPERATOR:
				sequence_BindOperator(context, (BindOperator) semanticObject); 
				return; 
			case SmagsPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case SmagsPackage.COMPONENT_TYPE:
				sequence_ComponentType(context, (ComponentType) semanticObject); 
				return; 
			case SmagsPackage.EXTERNAL_TYPE:
				sequence_ExternalType(context, (ExternalType) semanticObject); 
				return; 
			case SmagsPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SmagsPackage.META_ARCHITECTURE:
				sequence_MetaArchitecture(context, (MetaArchitecture) semanticObject); 
				return; 
			case SmagsPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case SmagsPackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case SmagsPackage.PORT_TYPE:
				sequence_PortType(context, (PortType) semanticObject); 
				return; 
			case SmagsPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case SmagsPackage.ROLE_MODEL:
				sequence_RoleModel(context, (RoleModel) semanticObject); 
				return; 
			case SmagsPackage.ROLE_MODEL_SLOT:
				sequence_RoleModelSlot(context, (RoleModelSlot) semanticObject); 
				return; 
			case SmagsPackage.SMAGS_MODEL:
				sequence_SmagsModel(context, (SmagsModel) semanticObject); 
				return; 
			case SmagsPackage.TYPE_BINDING:
				sequence_TypeBinding(context, (TypeBinding) semanticObject); 
				return; 
			case SmagsPackage.VARIABLE:
				if (rule == grammarAccess.getAnonymousVariableRule()) {
					sequence_AnonymousVariable(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableRule()
						|| rule == grammarAccess.getPortTypeElementRule()) {
					sequence_Variable(context, (Variable) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnonymousVariable returns Variable
	 *
	 * Constraint:
	 *     type=[Type|EString]
	 */
	protected void sequence_AnonymousVariable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.VARIABLE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnonymousVariableAccess().getTypeTypeEStringParserRuleCall_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SmagsElement returns Architecture
	 *     Architecture returns Architecture
	 *
	 * Constraint:
	 *     (name=EString type=[MetaArchitecture|EString] typeBindings+=TypeBinding* elements+=ArchitectureElement*)
	 */
	protected void sequence_Architecture(ISerializationContext context, Architecture semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositionOperator returns BindOperator
	 *     BindOperator returns BindOperator
	 *
	 * Constraint:
	 *     (to=[PortType|EString] slot=[RoleModelSlot|EString])
	 */
	protected void sequence_BindOperator(ISerializationContext context, BindOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.BIND_OPERATOR__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.BIND_OPERATOR__TO));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.BIND_OPERATOR__SLOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.BIND_OPERATOR__SLOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindOperatorAccess().getToPortTypeEStringParserRuleCall_3_0_1(), semanticObject.getTo());
		feeder.accept(grammarAccess.getBindOperatorAccess().getSlotRoleModelSlotEStringParserRuleCall_5_0_1(), semanticObject.getSlot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaArchitectureElement returns ComponentType
	 *     ComponentType returns ComponentType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ComponentType(ISerializationContext context, ComponentType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.META_ARCHITECTURE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.META_ARCHITECTURE_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentTypeAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArchitectureElement returns Component
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (name=EString type=[ComponentType|EString])
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.ARCHITECTURE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.ARCHITECTURE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.COMPONENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.COMPONENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getComponentAccess().getTypeComponentTypeEStringParserRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ExternalType
	 *     ExternalType returns ExternalType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ExternalType(ISerializationContext context, ExternalType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_0_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SmagsElement returns MetaArchitecture
	 *     MetaArchitecture returns MetaArchitecture
	 *
	 * Constraint:
	 *     (name=EString types+=Type* elements+=MetaArchitectureElement*)
	 */
	protected void sequence_MetaArchitecture(ISerializationContext context, MetaArchitecture semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *     PortTypeElement returns Method
	 *
	 * Constraint:
	 *     (returnType=AnonymousVariable name=EString (args+=Variable args+=Variable*)?)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaArchitectureElement returns PortType
	 *     PortType returns PortType
	 *
	 * Constraint:
	 *     (name=EString elements+=PortTypeElement*)
	 */
	protected void sequence_PortType(ISerializationContext context, PortType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArchitectureElement returns Port
	 *     Port returns Port
	 *
	 * Constraint:
	 *     (name=EString type=[PortType|EString])
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.ARCHITECTURE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.ARCHITECTURE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.PORT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.PORT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPortAccess().getTypePortTypeEStringParserRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns PrimitiveType
	 *     PrimitiveType returns PrimitiveType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, PrimitiveType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RoleModelSlot returns RoleModelSlot
	 *
	 * Constraint:
	 *     (type=[ComponentType|EString] name=EString)
	 */
	protected void sequence_RoleModelSlot(ISerializationContext context, RoleModelSlot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.ROLE_MODEL_SLOT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.ROLE_MODEL_SLOT__TYPE));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.ROLE_MODEL_SLOT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.ROLE_MODEL_SLOT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRoleModelSlotAccess().getTypeComponentTypeEStringParserRuleCall_1_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getRoleModelSlotAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaArchitectureElement returns RoleModel
	 *     RoleModel returns RoleModel
	 *
	 * Constraint:
	 *     (name=EString (slots+=RoleModelSlot slots+=RoleModelSlot*)? initialization+=CompositionOperator*)
	 */
	protected void sequence_RoleModel(ISerializationContext context, RoleModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SmagsModel returns SmagsModel
	 *
	 * Constraint:
	 *     (imports+=Import* elements+=SmagsElement*)
	 */
	protected void sequence_SmagsModel(ISerializationContext context, SmagsModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeBinding returns TypeBinding
	 *
	 * Constraint:
	 *     (type=[Type|EString] implementation=EString)
	 */
	protected void sequence_TypeBinding(ISerializationContext context, TypeBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.TYPE_BINDING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.TYPE_BINDING__TYPE));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.TYPE_BINDING__IMPLEMENTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.TYPE_BINDING__IMPLEMENTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeBindingAccess().getTypeTypeEStringParserRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getTypeBindingAccess().getImplementationEStringParserRuleCall_2_0(), semanticObject.getImplementation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *     PortTypeElement returns Variable
	 *
	 * Constraint:
	 *     (type=[Type|EString] name=EString)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, SmagsPackage.Literals.PORT_TYPE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmagsPackage.Literals.PORT_TYPE_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getTypeTypeEStringParserRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getVariableAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
